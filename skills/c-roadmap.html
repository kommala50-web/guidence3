<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>C Full Roadmap - TechPath</title>

<!-- Link CSS -->
<link rel="stylesheet" href="style.css">

</head>
<body>
<div class="floating-code" id="floatingCode"></div>

<header>
  <h1>TechPath</h1>
  <nav>
    <a href="../index.html">Home</a>
    <a href="../career.html">Career Paths</a>
    <a href="../skills.html">Skill Roadmaps</a>
    <a href="../company.html">Company Questions</a>
  </nav>
</header>

<section class="banner">
  <h2>üíª C Full Roadmap</h2>
  <p>Learn C from scratch to advanced concepts with explanations and example code.</p>
</section>

<div class="top-buttons">
  <a href="../skills.html" class="btn">‚Üê Back to Skills</a>
  <a href="../pdf/c.pdf" download="C_Roadmap.pdf" class="btn">Download PDF</a>
  <a href="../pdf/C_Notes.pdf" download="C_Notes.pdf" class="btn">Notes</a>
  <a href="https://www.youtube.com/watch?v=irqbmMNs2Bo" target="_blank" class="btn">Video Resource</a>
</div>

<section class="topic-container">

<!-- ======================= Topic Cards ======================= -->
<div class="topic-card">
<h3>1. Introduction to C</h3>
<p><strong>Description:</strong> C is a general-purpose procedural programming language. It's fast, close to hardware, and forms the foundation of many modern languages. Understanding C helps in learning memory management, pointers, and low-level operations.</p>
  <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
int main() {
    printf("Hello, C Programming!\n");
    return 0;
}
</pre>
</div>

<div class="topic-card">
<h3>2. Data Types & Variables</h3>
<p><strong>Description:</strong> C has basic types: int, char, float, double. Variables store data values. Understanding size, range, and initialization is key for memory-efficient code.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
int main() {
    int a = 10;
    char ch = 'A';
    float f = 3.14;
    printf("%d %c %.2f\n", a, ch, f);
    return 0;
}
</pre>
</div>

<div class="topic-card">
<h3>3. Operators</h3>
<p><strong>Description:</strong> Operators are symbols that perform operations on variables. Categories: arithmetic, relational, logical, bitwise, assignment, and ternary. Essential for expressions and calculations.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
int main() {
    int a=5, b=2;
    printf("Sum: %d\n", a+b);
    printf("AND: %d\n", a & b);
    printf("Conditional: %d\n", (a>b)?a:b);
    return 0;
}
</pre>
</div>

<div class="topic-card">
<h3>4. Control Statements</h3>
<p><strong>Description:</strong> Control statements alter the flow of execution: if, if-else, switch for decisions; for, while, do-while for loops; break & continue to manage loops.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
int main() {
    for(int i=1;i&lt;=5;i++){
        if(i==3) continue;
        printf("%d ",i);
    }
    return 0;
}
</pre>
</div>

<div class="topic-card">
<h3>5. Functions</h3>
<p><strong>Description:</strong> Functions group reusable code blocks. They enhance modularity and readability. Pass arguments by value, return results, and declare prototypes for better structure.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
int sum(int a,int b){ return a+b; }
int main(){
    printf("Sum: %d\n", sum(3,4));
    return 0;
}
</pre>
</div>

<div class="topic-card">
<h3>6. Arrays</h3>
<p><strong>Description:</strong> Arrays are collections of elements of the same type stored in contiguous memory. They allow efficient storage and manipulation of multiple values using indices. Understanding arrays is key to managing lists, tables, and matrices.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
int main(){
    int arr[5] = {1, 2, 3, 4, 5};
    for(int i=0;i&lt;5;i++){
        printf("%d ", arr[i]);
    }
    return 0;
}
// Output:
// 1 2 3 4 5
</pre>
</div>
<!-- 7. Strings -->
<div class="topic-card">
<h3>7. Strings</h3>
<p><strong>Description:</strong> Strings are arrays of characters ending with a null character '\\0'. They are used to store and manipulate text. Key functions include strcpy, strcat, strlen, strcmp from string.h.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(){
    char str1[20] = "Hello";
    char str2[] = "World";
    strcat(str1, str2); // Concatenate
    printf("%s\n", str1);
    printf("Length: %lu\n", strlen(str1));
    return 0;
}
// Output:
// HelloWorld
// Length: 10
</pre>
</div>

<!-- 8. Pointers -->
<div class="topic-card">
<h3>8. Pointers</h3>
<p><strong>Description:</strong> Pointers store memory addresses of variables. They allow dynamic memory management, efficient array handling, and function argument passing by reference. Understanding pointers is critical for advanced C programming.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
int main(){
    int a = 10;
    int *p = &a;
    printf("Value: %d, Address: %p\n", *p, p);
    return 0;
}
// Output:
// Value: 10, Address: 0x7ffeefbff5a4 (example)
</pre>
</div>

<!-- 9. Advanced Pointers -->
<div class="topic-card">
<h3>9. Advanced Pointers</h3>
<p><strong>Description:</strong> Pointers can be used for dynamic data manipulation and passing large structures efficiently. This example swaps two numbers without a temporary variable using pointers, demonstrating memory-level operations.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;

void swap(int *a, int *b){
    *a = *a + *b;
    *b = *a - *b;
    *a = *a - *b;
}

int main(){
    int x = 10, y = 20;
    printf("Before Swap: x=%d, y=%d\n", x, y);
    swap(&x, &y);
    printf("After Swap: x=%d, y=%d\n", x, y);
    return 0;
}
// Output:
// Before Swap: x=10, y=20
// After Swap: x=20, y=10
</pre>
</div>

<!-- 10. Structures -->
<div class="topic-card">
<h3>10. Structures</h3>
<p><strong>Description:</strong> Structures group variables of different types under a single name. They are useful for modeling real-world entities like students, books, or employees. Access members using the dot operator.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
struct Student {
    char name[20];
    int age;
};
int main(){
    struct Student s1 = {"Alice", 21};
    printf("Name: %s, Age: %d\n", s1.name, s1.age);
    return 0;
}
// Output:
// Name: Alice, Age: 21
</pre>
</div>

<!-- 11. Advanced Structures -->
<div class="topic-card">
<h3>11. Advanced Structures</h3>
<p><strong>Description:</strong> Structures can represent real-world entities. This example calculates total and average marks for multiple students, demonstrating practical usage of grouped data.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;

struct Student {
    char name[20];
    int marks[3];
    int total;
    float avg;
};

int main(){
    struct Student s[3] = { {"Alice",{85,90,95}}, {"Bob",{70,80,75}}, {"Charlie",{60,65,70}} };

    for(int i=0;i&lt;3;i++){
        s[i].total = s[i].marks[0] + s[i].marks[1] + s[i].marks[2];
        s[i].avg = s[i].total / 3.0;
        printf("Name: %s, Total: %d, Average: %.2f\n", s[i].name, s[i].total, s[i].avg);
    }
    return 0;
}
// Output:
// Name: Alice, Total: 270, Average: 90.00
// Name: Bob, Total: 225, Average: 75.00
// Name: Charlie, Total: 195, Average: 65.00
</pre>
</div>

<!-- 12. File I/O -->
<div class="topic-card">
<h3>12. File Input/Output</h3>
<p><strong>Description:</strong> File I/O allows reading from and writing to files. Use fopen, fprintf, fscanf, fread, fwrite, and fclose. It's essential for data storage and processing outside program execution.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
int main(){
    FILE *f = fopen("example.txt","w");
    fprintf(f,"Hello C File I/O");
    fclose(f);
    return 0;
}
// Output:
// Creates a file 'example.txt' containing: Hello C File I/O
</pre>
</div>
<!-- 13. Advanced File Handling -->
<div class="topic-card">
<h3>13. Advanced File Handling</h3>
<p><strong>Description:</strong> Files store persistent data. This example writes employee records to a file and reads them back, simulating a simple database operation.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;

struct Employee {
    int id;
    char name[20];
    float salary;
};

int main(){
    FILE *fp;
    struct Employee e[2] = { {101,"Alice",50000}, {102,"Bob",60000} };

    // Writing to file
    fp = fopen("employees.txt","w");
    for(int i=0;i&lt;2;i++)
        fprintf(fp,"%d %s %.2f\\n", e[i].id, e[i].name, e[i].salary);
    fclose(fp);

    // Reading from file
    struct Employee temp;
    fp = fopen("employees.txt","r");
    printf("Employee Records:\\n");
    while(fscanf(fp,"%d %s %f",&temp.id,temp.name,&temp.salary) != EOF){
        printf("ID:%d Name:%s Salary:%.2f\\n", temp.id,temp.name,temp.salary);
    }
    fclose(fp);
    return 0;
}
// Output:
// Employee Records:
// ID:101 Name:Alice Salary:50000.00
// ID:102 Name:Bob Salary:60000.00
</pre>
</div>

<!-- 14. Dynamic Memory Allocation -->
<div class="topic-card">
<h3>14. Dynamic Memory Allocation</h3>
<p><strong>Description:</strong> Allocate memory at runtime using malloc, calloc, realloc, and free. Useful when array size or data is unknown at compile time. Helps in memory-efficient programs.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main(){
    int arr = (int)malloc(5 * sizeof(int));
    for(int i=0;i&lt;5;i++) arr[i] = i+1;
    for(int i=0;i&lt;5;i++) printf("%d ", arr[i]);
    free(arr);
    return 0;
}
// Output:
// 1 2 3 4 5
</pre>
</div>

<!-- 15. Advanced Dynamic Memory Allocation -->
<div class="topic-card">
<h3>15. Advanced Dynamic Memory Allocation</h3>
<p><strong>Description:</strong> Allocate memory at runtime for user-defined data. This example dynamically stores numbers entered by the user and computes their sum.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(){
    int n, sum=0;
    printf("Enter number of elements: ");
    scanf("%d", &n);

    int arr = (int)malloc(n * sizeof(int));
    if(arr == NULL) { printf("Memory allocation failed\\n"); return 1; }

    for(int i=0;i&lt;n;i++){
        printf("Enter number %d: ", i+1);
        scanf("%d", &arr[i]);
        sum += arr[i];
    }

    printf("Sum of all numbers: %d\n", sum);
    free(arr);
    return 0;
}
// Output (example):
// Enter number of elements: 4
// Enter number 1: 10
// Enter number 2: 20
// Enter number 3: 30
// Enter number 4: 40
// Sum of all numbers: 100
</pre>
</div>


<!-- 16. Recursion -->
<div class="topic-card">
<h3>16. Recursion</h3>
<p><strong>Description:</strong> Recursion is when a function calls itself. Useful for problems like factorial, Fibonacci, and tree traversal. Always ensure a base case to prevent infinite recursion.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
int factorial(int n){
    if(n==0) return 1;
    return n*factorial(n-1);
}
int main(){
    printf("Factorial of 5: %d\n", factorial(5));
    return 0;
}
// Output:
// Factorial of 5: 120
</pre>
</div>

<!-- 17. Advanced Recursion -->
<div class="topic-card">
<h3>17. Advanced Recursion</h3>
<p><strong>Description:</strong> Recursion allows elegant solutions for repetitive problems. This example calculates factorial of a number, a common combinatorial operation.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;

long factorial(int n){
    if(n==0) return 1;
    return n * factorial(n-1);
}

int main(){
    int num = 6;
    printf("Factorial of %d is %ld\n", num, factorial(num));
    return 0;
}
// Output:
// Factorial of 6 is 720
</pre>
</div>
<!-- 18. Linked List -->
<div class="topic-card">
<h3>18. Linked List</h3>
<p><strong>Description:</strong> A linked list is a dynamic data structure where each element (node) points to the next. Useful for inserting/deleting elements without shifting memory like arrays.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int data;
    struct Node *next;
};

int main(){
    struct Node *head = NULL;
    struct Node *second = NULL;
    struct Node *third = NULL;

    head = (struct Node*)malloc(sizeof(struct Node));
    second = (struct Node*)malloc(sizeof(struct Node));
    third = (struct Node*)malloc(sizeof(struct Node));

    head-&gt;data = 10; head-&gt;next = second;
    second-&gt;data = 20; second-&gt;next = third;
    third-&gt;data = 30; third-&gt;next = NULL;

    struct Node *ptr = head;
    while(ptr != NULL){
        printf("%d ", ptr-&gt;data);
        ptr = ptr-&gt;next;
    }
    return 0;
}
// Output:
// 10 20 30
</pre>
</div>

<!-- 19. Stack -->
<div class="topic-card">
<h3>19. Stack</h3>
<p><strong>Description:</strong> Stack is a LIFO (Last-In-First-Out) structure. Commonly used in recursion, expression evaluation, and undo operations. Push adds and pop removes elements from the top.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
#define MAX 5

int stack[MAX];
int top = -1;

void push(int val){
    if(top == MAX-1) printf("Stack Overflow\\n");
    else stack[++top] = val;
}

int pop(){
    if(top == -1) { printf("Stack Underflow\\n"); return -1; }
    return stack[top--];
}

int main(){
    push(10); push(20); push(30);
    printf("Popped: %d\\n", pop());
    printf("Popped: %d\\n", pop());
    return 0;
}
// Output:
// Popped: 30
// Popped: 20
</pre>
</div>

<!-- 20. Queue -->
<div class="topic-card">
<h3>20. Queue</h3>
<p><strong>Description:</strong> Queue is a FIFO (First-In-First-Out) structure. Used in scheduling, buffering, and resource management. Enqueue adds and Dequeue removes elements from the front.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
#define SIZE 5

int queue[SIZE], front=-1, rear=-1;

void enqueue(int val){
    if(rear == SIZE-1) printf("Queue Full\\n");
    else {
        if(front == -1) front = 0;
        queue[++rear] = val;
    }
}

int dequeue(){
    if(front == -1 || front &gt; rear) { printf("Queue Empty\\n"); return -1; }
    return queue[front++];
}

int main(){
    enqueue(10); enqueue(20); enqueue(30);
    printf("Dequeued: %d\\n", dequeue());
    printf("Dequeued: %d\\n", dequeue());
    return 0;
}
// Output:
// Dequeued: 10
// Dequeued: 20
</pre>
</div>

<!-- 21. Matrix Operations -->
<div class="topic-card">
<h3>21. Matrix Operations</h3>
<p><strong>Description:</strong> Matrices are 2D arrays. Common operations include addition, subtraction, and multiplication. Used in graphics, simulations, and scientific computing.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;

int main(){
    int A[2][2] = {{1,2},{3,4}};
    int B[2][2] = {{5,6},{7,8}};
    int C[2][2];

    // Addition
    for(int i=0;i&lt;2;i++)
        for(int j=0;j&lt;2;j++)
            C[i][j] = A[i][j] + B[i][j];

    printf("Matrix Addition:\\n");
    for(int i=0;i&lt;2;i++){
        for(int j=0;j&lt;2;j++)
            printf("%d ", C[i][j]);
        printf("\\n");
    }
    return 0;
}
// Output:
// Matrix Addition:
// 6 8
// 10 12
</pre>
</div>
<!-- 22. Sorting Algorithms -->
<div class="topic-card">
<h3>22. Sorting Algorithms</h3>
<p><strong>Description:</strong> Sorting arranges data in a particular order. Common algorithms: Bubble Sort, Selection Sort, Insertion Sort. Sorting is crucial for efficient searching and data processing.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;

int main(){
    int arr[5] = {5,2,9,1,6}, temp;
    // Bubble Sort
    for(int i=0;i&lt;5-1;i++){
        for(int j=0;j&lt;5-i-1;j++){
            if(arr[j] &gt; arr[j+1]){
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
    printf("Sorted Array: ");
    for(int i=0;i&lt;5;i++) printf("%d ", arr[i]);
    return 0;
}
// Output:
// Sorted Array: 1 2 5 6 9
</pre>
</div>

<!-- 23. Searching Algorithms -->
<div class="topic-card">
<h3>23. Searching Algorithms</h3>
<p><strong>Description:</strong> Searching is locating a value within a dataset. Common methods: Linear Search and Binary Search. Efficient searching is critical for large datasets.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;

int main(){
    int arr[5] = {1,2,5,6,9}, key=5;
    int found = -1;
    // Linear Search
    for(int i=0;i&lt;5;i++){
        if(arr[i]==key){ found=i; break; }
    }
    if(found != -1) printf("Element %d found at index %d\\n", key, found);
    else printf("Element not found\\n");
    return 0;
}
// Output:
// Element 5 found at index 2
</pre>
</div>

<!-- 24. Bitwise Operations -->
<div class="topic-card">
<h3>24. Bitwise Operations</h3>
<p><strong>Description:</strong> Bitwise operators manipulate individual bits of data. Common operators: AND(&amp;), OR(|), XOR(^), NOT(~), shift (&lt;&lt;, &gt;&gt;). Useful in encryption, compression, and low-level programming.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;

int main(){
    int a=5, b=3;
    printf("AND: %d\\n", a & b);
    printf("OR: %d\\n", a | b);
    printf("XOR: %d\\n", a ^ b);
    printf("Left Shift: %d\\n", a &lt;&lt;1);
    printf("Right Shift: %d\\n", a &gt;&gt;1);
    return 0;
}
// Output:
// AND: 1
// OR: 7
// XOR: 6
// Left Shift: 10
// Right Shift: 2
</pre>
</div>

<!-- 25. Advanced File Handling -->
<div class="topic-card">
<h3>25. Advanced File Handling</h3>
<p><strong>Description:</strong> Advanced file operations include reading/writing binary files, appending data, and using fseek, ftell. Useful for databases, images, and storing complex data structures.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;

struct Student {
    char name[20];
    int age;
};

int main(){
    struct Student s1 = {"Alice", 21};
    FILE *f = fopen("students.dat","wb"); // write binary
    fwrite(&amp;s1, sizeof(s1), 1, f);
    fclose(f);

    struct Student s2;
    f = fopen("students.dat","rb"); // read binary
    fread(&amp;s2, sizeof(s2), 1, f);
    fclose(f);

    printf("Name: %s, Age: %d\\n", s2.name, s2.age);
    return 0;
}
// Output:
// Name: Alice, Age: 21
</pre>
</div>
<!-- 26. Macros & Preprocessor Directives -->
<div class="topic-card">
<h3>26. Macros & Preprocessor Directives</h3>
<p><strong>Description:</strong> Macros define reusable code snippets using #define. Preprocessor directives like #include, #ifdef, #ifndef, #undef help in conditional compilation and modular code.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
#define PI 3.14159

int main(){
    printf("Value of PI: %.2f\\n", PI);
    return 0;
}
// Output:
// Value of PI: 3.14
</pre>
</div>

<!-- 27. Command Line Arguments -->
<div class="topic-card">
<h3>27. Command Line Arguments</h3>
<p><strong>Description:</strong> C programs can accept input from the command line using argc (argument count) and argv (argument vector). Useful for automation and scripting.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;

int main(int argc, char *argv[]){
    printf("Number of arguments: %d\\n", argc);
    for(int i=0;i&lt;argc;i++){
        printf("Arg %d: %s\\n", i, argv[i]);
    }
    return 0;
}
// Output (example):
// Number of arguments: 3
// Arg 0: ./program
// Arg 1: test
// Arg 2: 123
</pre>
</div>

<!-- 28. Multi-file Programs -->
<div class="topic-card">
<h3>28. Multi-file Programs</h3>
<p><strong>Description:</strong> Large programs are split across multiple files. Use header files (.h) and include them with #include. Helps in modularity, reusability, and team projects.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>
// file1.h
#ifndef FILE1_H
#define FILE1_H
void greet();
#endif

// file1.c
#include &lt;stdio.h&gt;
#include "file1.h"
void greet(){ printf("Hello from file1!\\n"); }

// main.c
#include "file1.h"
int main(){
    greet();
    return 0;
}
// Output:
// Hello from file1!
</pre>
</div>

<!-- 29. Error Handling & Debugging -->
<div class="topic-card">
<h3>29. Error Handling & Debugging</h3>
<p><strong>Description:</strong> Detect and handle runtime errors using return values, errno, and perror. Debug using gdb, printf debugging, or IDE tools. Essential for reliable programs.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

int main(){
    FILE *f = fopen("nonexistent.txt","r");
    if(!f){
        printf("Error opening file: %s\\n", strerror(errno));
    }
    return 0;
}
// Output (example):
// Error opening file: No such file or directory
</pre>
</div>

<!-- 30. Linked Lists -->
<div class="topic-card">
<h3>30. Linked Lists</h3>
<p><strong>Description:</strong> Linked lists are dynamic data structures where elements (nodes) point to the next node. They allow efficient insertion/deletion compared to arrays. Useful in real-time applications.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int data;
    struct Node* next;
};

int main(){
    struct Node* head = (struct Node*)malloc(sizeof(struct Node));
    struct Node* second = (struct Node*)malloc(sizeof(struct Node));
    head-&gt;data = 1; head-&gt;next = second;
    second-&gt;data = 2; second-&gt;next = NULL;

    struct Node* ptr = head;
    while(ptr != NULL){
        printf("%d ", ptr-&gt;data);
        ptr = ptr-&gt;next;
    }
    free(second); free(head);
    return 0;
}
// Output:
// 1 2
</pre>
</div>

<!-- 31. Stack & Queue Implementation -->
<div class="topic-card">
<h3>31. Stack & Queue Implementation</h3>
<p><strong>Description:</strong> Stack (LIFO) and Queue (FIFO) are abstract data types. Implement using arrays or linked lists. Useful in function call management, scheduling, and task processing.</p>
 <button class="toggle-code">Show Example</button>
  <pre class="code-snippet" style="display:none;">
<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define SIZE 5
int stack[SIZE], top=-1;

void push(int x){ if(top&lt;SIZE-1) stack[++top]=x; }
int pop(){ return (top&gt;=-1)?stack[top--]:-1; }

int main(){
    push(1); push(2); push(3);
    printf("%d ", pop());
    printf("%d ", pop());
    return 0;
}
// Output:
// 3¬†2
</pre>
</div>

<!-- Add all other topic cards from 7 to 31 exactly as in your original code -->

</section>
<script>
document.querySelectorAll('.toggle-code').forEach(btn => {
  btn.addEventListener('click', () => {
    const code = btn.nextElementSibling;
    if (code.style.display === 'none' || code.style.display === "") {
      code.style.display = 'block';
      code.style.maxHeight = code.scrollHeight + "px";
    } else {
      code.style.display = 'none';
      code.style.maxHeight = 0;
    }
  });
});
</script>


<footer>
  Contact: techpath@example.com | ¬© 2025 TechPath
</footer>


<!-- Link JS -->
<script src="app.js"></script>

</body>
</html>
